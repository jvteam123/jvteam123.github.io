<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Tracker</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; 
            margin: 0; 
            background-color: #f4f7f6; 
            color: #333; 
            line-height: 1.6; /* Adjusted line-height for better readability */
        }
        .container { 
            width: 98%; 
            max-width: 1900px; 
            margin: 10px auto; 
            padding: 10px; 
            background-color: #fff; 
            box-shadow: 0 2px 15px rgba(0,0,0,0.08); /* Softer shadow */
            border-radius: 8px; /* Slightly more rounded corners */
        }
        
        /* ====== Improved Auth Section Styles ====== */
        #auth-container {
            background-color: #ffffff; /* Cleaner background */
            padding: 25px 20px; /* More padding */
            border-radius: 8px; /* Consistent rounding */
            box-shadow: 0 1px 4px rgba(0,0,0,0.07); /* Subtle shadow for depth */
            margin-bottom: 25px;
            text-align: center;
        }

        #auth-container h2.auth-title { /* Added class for specific targeting */
            font-size: 1.4em; /* Slightly larger title */
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 20px; /* More space below title */
            color: #2c3e50;
        }

        #signInBtn {
            background-color: #4285F4; /* Google Blue */
            color: white;
            padding: 12px 28px; /* Enhanced padding */
            font-size: 1em;
            font-weight: 500; /* Medium weight */
            border: none;
            border-radius: 4px;
            box-shadow: 0 2px 4px 0 rgba(0,0,0,0.20);
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 12px; /* Space for potential icon */
            cursor: pointer;
        }
        #signInBtn:hover {
            background-color: #357ae8;
            box-shadow: 0 3px 6px 0 rgba(0,0,0,0.25);
        }
        /* To add a Google Icon (e.g. SVG) you'd insert it inside the button HTML */
        /* #signInBtn svg { width: 18px; height: 18px; } */

        #user-info-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 18px; /* Increased gap */
            flex-wrap: wrap;
            margin-top: 10px; /* Space above user info when sign-in button is hidden */
        }

        #user-info-display img#userPhoto {
            width: 50px; /* Larger photo */
            height: 50px;
            border-radius: 50%;
            border: 2px solid #e0e0e0; /* Softer border */
        }

        #user-info-display .user-details {
            text-align: center; /* Centered text for details */
        }
        @media (min-width: 480px) { /* Align left on larger screens */
            #user-info-display .user-details {
                text-align: left;
            }
        }


        #user-info-display .user-details p {
            margin: 2px 0; /* Adjusted margin */
            line-height: 1.4;
            font-size: 0.95em; /* Slightly larger detail font */
            color: #454545; /* Darker grey for readability */
        }

        #user-info-display .user-details p#userName {
            font-weight: 600; /* Bolder name */
            font-size: 1.1em;
            color: #2c3e50;
        }

        #signOutBtn {
            background-color: #e74c3c;
            color: white;
            padding: 10px 20px; /* Consistent padding */
            font-size: 0.9em;
            font-weight: 500;
            border: none;
            border-radius: 4px;
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }
        #signOutBtn:hover {
            background-color: #c0392b;
        }
        /* ====== End Improved Auth Section Styles ====== */


        /* Initially hide app content and show loading/auth message */
        #app-content { display: none; }
        #loading-auth-message { text-align: center; padding: 25px; font-size: 1.15em; color: #555;}


        h1, h2:not(.auth-title), h3 { color: #2c3e50; text-align: center; margin-bottom: 12px; font-size: 1.5em; }
        h2:not(.auth-title) { font-size: 1.3em; }
        h3 { font-size: 1.1em; text-align: left; margin-top: 15px; border-bottom: 1px solid #ccc; padding-bottom: 5px;}
        .action-bar { margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; }
        .btn { padding: 4px 8px; border: none; border-radius: 3px; cursor: pointer; font-size: 0.8em; transition: background-color 0.3s ease; margin: 2px; min-width: 60px; text-align: center; vertical-align: middle;}
        .btn-lg { padding: 7px 12px; font-size: 0.9em; }
        .btn-group-toggle { min-width: 25px; padding: 2px 6px; font-size: 0.9em; margin-left: 10px; background-color: #7f8c8d; color:white; }
        .btn-group-toggle:hover { background-color: #95a5a6;}
        .btn-danger { background-color: #e74c3c; color: white; } .btn-danger:hover { background-color: #c0392b; }
        .btn-primary { background-color: #3498db; color: white; } .btn-primary:hover { background-color: #2980b9; }
        .btn-success { background-color: #2ecc71; color: white; } .btn-success:hover { background-color: #27ae60; }
        .btn-mark-done { background-color: #1abc9c; color: white; } .btn-mark-done:hover { background-color: #16a085; }
        .btn-release { background-color: #9b59b6; color: white; font-size:0.85em; padding: 5px 10px; } .btn-release:hover { background-color: #8e44ad; }
        .btn-day-start { background-color: #007bff; color: white; }
        .btn-day-start:hover { background-color: #0056b3; }
        .btn-day-end { background-color: #fd7e14; color: white; }
        .btn-day-end:hover { background-color: #c85e08; }
        .btn-warning { background-color: #f39c12; color: white; }
        .btn-warning:hover { background-color: #e67e22; }
        .btn:disabled { background-color: #bdc3c7 !important; color: #7f8c8d !important; cursor: not-allowed; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 15px; border: 1px solid #888; width: 90%; border-radius: 5px; position: relative; }
        #projectFormModal .modal-content { max-width: 480px; }
        #tlDashboardModal .modal-content { max-width: 750px; max-height: 85vh; overflow-y: auto;}
        .close-button { color: #aaa; float: right; font-size: 24px; font-weight: bold; } .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        #newProjectForm label { display: block; margin-top: 8px; font-weight: bold; font-size: 0.85em;}
        #newProjectForm input[type="text"], #newProjectForm input[type="number"], #newProjectForm select { width: calc(100% - 18px); padding: 7px; margin-top: 3px; border: 1px solid #ddd; border-radius: 3px; box-sizing: border-box; font-size: 0.85em; }
        #newProjectForm button[type="submit"] { margin-top: 12px; }
        #projectTable { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.8em; }
        #projectTable th, #projectTable td { border: 1px solid #ddd; padding: 3px 5px; text-align: left; vertical-align: middle; white-space: nowrap; }
        #projectTable thead th { background-color: #34495e; color: white; font-weight: bold; position: sticky; top: 0; z-index: 10;}
        #projectTable td.wrap-text { white-space: normal; }
        #projectTable input[type="text"].assigned-to-input, #projectTable textarea.tech-notes-input { width: calc(100% - 6px); padding: 2px; border: 1px solid #ccc; border-radius: 2px; box-sizing: border-box; font-size: 1em; background-color: #fff; }
        #projectTable textarea.tech-notes-input { resize: vertical; min-height: 18px; line-height: 1.3; }
        .batch-header-row td { background-color: #6c757d !important; color: white; font-size: 1.1em; font-weight: bold; text-align: left; padding: 6px 8px; }
        .fix-group-header td { background-color: #adb5bd !important; color: #212529; font-size: 1.0em; font-weight: bold; text-align: left; padding: 4px 8px; cursor:pointer; padding-left: 30px; }
        .hidden-group-row { display: none; }
        .overall-project-separator td { height: 10px !important; background-color: #e9ecef !important; border: none !important; padding: 0 !important; }
        #projectTable td.duration-column { color: #0056b3; font-weight: bold; }
        #projectTable td.total-duration-column { color: #004085; font-weight: bold; background-color: #f0f4f8; }
        .fix1-row { background-color: #e6ffe6; }
        .fix2-row { background-color: #ffe6f2; }
        .fix3-row { background-color: #e6e6ff; }
        .fix4-row { background-color: #fff5e6; }
        .reassigned-task-highlight { background-color: #FFF9C4 !important; }
        #projectTable tbody tr:not(.fix-group-header):not(.batch-header-row):not(.overall-project-separator):hover { background-color: #d0e0f0 !important; }
        .status { padding: 2px 5px; border-radius: 3px; color: white; font-weight: bold; text-align: center; display: inline-block; font-size:0.95em; }
        .status-available { background-color: #3498db; }
        .status-inprogressday1 { background-color: #f39c12; }
        .status-day1ended_awaitingnext { background-color: #e67e22; } /* Different color from inprogress */
        .status-inprogressday2 { background-color: #f39c12; }
        .status-completed { background-color: #2ecc71; }
        .status-reassigned_techabsent { background-color: #B0BEC5; color: #263238; }
        #tlDashboardContent { margin-top:15px; }
        .dashboard-batch-item { border: 1px solid #bdc3c7; padding: 10px; margin-bottom: 10px; background-color: #fff; border-radius: 4px; }
        .dashboard-batch-item h4 { margin-top: 0; margin-bottom: 8px; font-size: 1.05em; color: #34495e;}
        .dashboard-batch-item p { margin: 3px 0; font-size: 0.9em;}
        .dashboard-batch-actions-release { margin-top: 8px; margin-bottom: 8px; }
        .dashboard-batch-actions-delete { margin-top: 8px; border-top: 1px dashed #ccc; padding-top: 8px; display: flex; flex-wrap: wrap; gap: 5px;}
    </style>
</head>
<body>
    <div class="container">
        <div id="auth-container">
            <h2 class="auth-title">Project Tracker Access</h2>
            <button id="signInBtn" style="display: none;"> Sign in with Google
            </button>
            
            <div id="user-info-display" style="display: none;">
                <img id="userPhoto" src="" alt="User Photo">
                <div class="user-details">
                    <p id="userName"></p>
                    <p id="userEmail"></p>
                </div>
                <button id="signOutBtn">Sign Out</button>
            </div>
        </div>
        <div id="loading-auth-message">
            <p>Authenticating... Please wait.</p>
        </div>
        
        <div id="app-content">
            <h1>123 Project Tracker</h1>
            <div class="action-bar">
                <button id="openAddNewProjectBtn" class="btn btn-success btn-lg">➕ Add New Tracker</button>
                <button id="openTlDashboardBtn" class="btn btn-primary btn-lg">👑 TL Dashboard</button>
            </div>

            <div id="projectFormModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeProjectFormBtn">&times;</span>
                    <h2>Add New Tracker</h2>
                    <form id="newProjectForm">
                        <label for="fixCategorySelect">Fix Category:</label>
                        <select id="fixCategorySelect" required><option value="Fix1">Fix1</option><option value="Fix2">Fix2</option><option value="Fix3">Fix3</option><option value="Fix4">Fix4</option></select>
                        <label for="numRows">Number of Tasks/Rows:</label>
                        <input type="number" id="numRows" value="1" min="1" required>
                        <label for="baseProjectName">Base Project Name:</label>
                        <input type="text" id="baseProjectName" value="PROJ_ID_XYZ" required>
                        <label for="gsd">GSD:</label>
                        <select id="gsd" required><option value="3in">3in</option><option value="9in">9in</option></select>
                        <button type="submit" class="btn btn-success">Add Project(s)</button>
                    </form>
                </div>
            </div>

            <div id="tlDashboardModal" class="modal">
                <div class="modal-content">
                    <span class="close-button" id="closeTlDashboardBtn">&times;</span>
                    <h2>👑 Team Lead Dashboard</h2>
                    <div id="tlDashboardContent"></div>
                </div>
            </div>

            <h3>📌 Project Details</h3>
            <table id="projectTable">
                <thead>
                    <tr>
                        <th>Fix</th><th style="min-width: 150px;">Project Name</th><th style="min-width: 80px;">Area</th><th>GSD</th>
                        <th style="min-width: 80px;">Assigned Tech</th><th style="min-width: 120px;">Status</th>
                        <th>D1 Start</th><th>D1 End</th><th>D1 Dur(m)</th>
                        <th>D2 Start</th><th>D2 End</th><th>D2 Dur(m)</th>
                        <th>Total(m)</th><th style="min-width: 120px;">Tech Notes</th><th style="min-width: 150px;">Actions</th>
                    </tr>
                </thead>
                <tbody id="projectTableBody"></tbody>
            </table>
        </div> </div> <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    
    <script>
        // CRITICAL SECURITY WARNING: Your Firebase API keys are exposed here.
        // For production, secure your data with Firebase Security Rules and restrict API key usage in Google Cloud Console.
        const firebaseConfig = {
          apiKey: "AIzaSyADB1W9YKaU6DFqGyjivsADJOhuIRY0eZ0", // Replace with your actual key if different
          authDomain: "project-tracker-fddb1.firebaseapp.com",
          projectId: "project-tracker-fddb1",
          storageBucket: "project-tracker-fddb1.firebasestorage.app",
          messagingSenderId: "698282455986",
          appId: "1:698282455986:web:f31fa7830148dc47076aab",
          measurementId: "G-6D2Z9ZWEN1"
        };

        let app;
        let db;
        let auth; // Firebase Auth instance

        // DOM elements for Auth
        let signInBtn, signOutBtn, userInfoDisplayDiv, userNameP, userEmailP, userPhotoImg;
        // DOM elements for app state
        let appContentDiv, loadingAuthMessageDiv;


        try {
            if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                throw new Error("Firebase SDK not loaded. Ensure Firebase scripts are correctly included.");
            }
            app = firebase.initializeApp(firebaseConfig);
            
            if (typeof app.firestore === 'undefined') {
                 throw new Error("Firestore SDK not loaded or initialized correctly with the app.");
            }
            db = firebase.firestore();

            if (typeof app.auth === 'undefined') {
                throw new Error("Firebase Auth SDK not loaded or initialized correctly with the app.");
            }
            auth = firebase.auth(); 

            console.log("Firebase initialized successfully (App, Firestore, Auth)!");
        } catch (e) {
            console.error("CRITICAL: Error initializing Firebase: ", e.message);
            const loadingMsgDiv = document.getElementById('loading-auth-message');
            if (loadingMsgDiv) loadingMsgDiv.innerHTML = `<p style="color:red;">CRITICAL ERROR: Could not connect to Firebase. App will not function correctly. Error: ${e.message}</p>`;
            else alert("CRITICAL ERROR: Could not connect to Firebase. App will not function correctly. Error: " + e.message);
        }

        const FIX_CATEGORIES_ORDER = ["Fix1", "Fix2", "Fix3", "Fix4"];
        const STATUS_ORDER = {
            'Available': 1, 'InProgressDay1': 2, 'Day1Ended_AwaitingNext': 3,
            'InProgressDay2': 4, 'Completed': 5, 'Reassigned_TechAbsent': 6
        };
        const NUM_TABLE_COLUMNS = 15;

        let openAddNewProjectBtn, openTlDashboardBtn, projectFormModal, tlDashboardModal,
            closeProjectFormBtn, closeTlDashboardBtn, newProjectForm, projectTableBody,
            tlDashboardContentElement;

        let projects = [];
        let groupVisibilityState = {};
        let isAppInitialized = false; 
        let firestoreListenerUnsubscribe = null; 

        function generateId() { return Date.now().toString(36) + Math.random().toString(36).substr(2, 5); }
        function formatMillisToMinutes(millis) { return (millis === null || typeof millis !== 'number' || millis < 0) ? 'N/A' : Math.floor(millis / 60000); }

        function calculateDurationMs(startTime, endTime) {
            let startMillis = startTime; let endMillis = endTime;
            if (startTime && typeof startTime.toMillis === 'function') startMillis = startTime.toMillis();
            if (endTime && typeof endTime.toMillis === 'function') endMillis = endTime.toMillis();
            else if (typeof startTime === 'number' && typeof endTime === 'number') { /* proceed */ }
            else if (startTime && typeof startTime.toMillis === 'function' && typeof endTime === 'number') { /* endMillis is already a number */ }
            else if (typeof startTime === 'number' && endTime && typeof endTime.toMillis === 'function') { /* startMillis is already a number */ }
            else {
                 if (!startTime || !endTime) return null;
                 if (typeof startTime !== 'number' && !isNaN(new Date(startTime).getTime())) startMillis = new Date(startTime).getTime();
                 if (typeof endTime !== 'number' && !isNaN(new Date(endTime).getTime())) endMillis = new Date(endTime).getTime();
            }
            return (!startMillis || !endMillis || endMillis < startMillis || isNaN(startMillis) || isNaN(endMillis)) ? null : endMillis - startMillis;
        }
        
        function loadGroupVisibilityState() { 
            try { const savedState = localStorage.getItem('projectTrackerGroupVisibility'); if (savedState) groupVisibilityState = JSON.parse(savedState); else groupVisibilityState = {}; } catch (e) { console.error("Error parsing group visibility state from localStorage:", e); groupVisibilityState = {}; }
        }
        function saveGroupVisibilityState() { 
            try { localStorage.setItem('projectTrackerGroupVisibility', JSON.stringify(groupVisibilityState)); } catch (lsError) { console.error("Error saving group visibility state to localStorage:", lsError); alert("Warning: Could not save your group visibility preferences.");}
        }

        function initializeFirebaseAndLoadData() {
            if (!db) { console.error("Firestore (db) not initialized. Cannot load data."); alert("ERROR: Database connection failed. App cannot load data."); projects = []; refreshAllViews(); return; }
            if (firestoreListenerUnsubscribe) { firestoreListenerUnsubscribe(); console.log("Previous Firestore listener detached."); }
            loadGroupVisibilityState();
            try {
                firestoreListenerUnsubscribe = db.collection("projects").orderBy("batchId").orderBy("fixCategory").orderBy("areaTask")
                  .onSnapshot((querySnapshot) => {
                    const firebaseProjects = [];
                    querySnapshot.forEach((doc) => { if (doc.exists && typeof doc.data === 'function') firebaseProjects.push({ id: doc.id, ...doc.data() }); });
                    projects = firebaseProjects;
                    projects.forEach(p => { if (p && p.batchId && p.fixCategory) { const groupStateKey = `${p.batchId}_${p.fixCategory}`; if (groupVisibilityState[groupStateKey] === undefined) groupVisibilityState[groupStateKey] = { isExpanded: true }; } });
                    refreshAllViews();
                }, (error) => { 
                    console.error("Error fetching projects from Firebase (onSnapshot): ", error); 
                    alert("Error fetching projects. Check console. Error: " + error.message + "\n\nThis could be due to Firebase Security Rules denying access."); 
                    projects = []; refreshAllViews(); 
                });
                console.log("New Firestore listener attached.");
            } catch (fbError) { console.error("CRITICAL Error setting up Firebase listener: ", fbError); alert("A critical error occurred while listening for project updates. Error: " + fbError.message); }
        }

        function setupDOMReferences() {
            openAddNewProjectBtn = document.getElementById('openAddNewProjectBtn');
            openTlDashboardBtn = document.getElementById('openTlDashboardBtn');
            projectFormModal = document.getElementById('projectFormModal');
            tlDashboardModal = document.getElementById('tlDashboardModal');
            closeProjectFormBtn = document.getElementById('closeProjectFormBtn');
            closeTlDashboardBtn = document.getElementById('closeTlDashboardBtn');
            newProjectForm = document.getElementById('newProjectForm');
            projectTableBody = document.getElementById('projectTableBody');
            tlDashboardContentElement = document.getElementById('tlDashboardContent');
            if (!openAddNewProjectBtn || !newProjectForm || !projectTableBody || !tlDashboardContentElement || !projectFormModal || !tlDashboardModal) console.error("CRITICAL DOM ERROR: One or more essential tracker elements not found!");
        }

        function attachEventListeners() {
            if (openAddNewProjectBtn) openAddNewProjectBtn.onclick = () => { if (projectFormModal) projectFormModal.style.display = 'block'; else console.error("Cannot open Add Project modal: projectFormModal is null."); };
            if (closeProjectFormBtn) closeProjectFormBtn.onclick = () => { if (projectFormModal) projectFormModal.style.display = 'none'; };
            if (openTlDashboardBtn) { openTlDashboardBtn.onclick = () => { if (tlDashboardModal) { tlDashboardModal.style.display = 'block'; renderTLDashboard(); } else console.error("Cannot open TL Dashboard: tlDashboardModal is null."); }; }
            if (closeTlDashboardBtn) closeTlDashboardBtn.onclick = () => { if (tlDashboardModal) tlDashboardModal.style.display = 'none'; };
            if (typeof window !== 'undefined') { window.onclick = (event) => { if (projectFormModal && event.target == projectFormModal) projectFormModal.style.display = 'none'; if (tlDashboardModal && event.target == tlDashboardModal) tlDashboardModal.style.display = 'none'; }; }
            if (newProjectForm) newProjectForm.addEventListener('submit', handleAddProjectSubmit); else console.error("Cannot attach submit listener: newProjectForm not found.");
        }

        async function handleAddProjectSubmit(e) { e.preventDefault(); if (!db) { alert("CRITICAL: Database not initialized! Cannot add projects."); return; } const fixCategoryElement = document.getElementById('fixCategorySelect'); const numRowsElement = document.getElementById('numRows'); const baseProjectNameElement = document.getElementById('baseProjectName'); const gsdElement = document.getElementById('gsd'); if (!fixCategoryElement || !numRowsElement || !baseProjectNameElement || !gsdElement) { alert("Error: Form elements missing. Could not submit."); return; } const fixCategory = fixCategoryElement.value; const numRows = parseInt(numRowsElement.value, 10); const baseProjectNameVal = baseProjectNameElement.value.trim(); const gsd = gsdElement.value; if (!baseProjectNameVal) { alert("Base Project Name cannot be empty."); return; } if (isNaN(numRows) || numRows < 1) { alert("Number of Tasks must be a positive number."); return; } const currentBatchId = "batch_" + generateId(); const batchCreationTimestamp = firebase.firestore.FieldValue.serverTimestamp(); const fbBatch = db.batch(); try { for (let i = 1; i <= numRows; i++) { const currentAreaTask = `Area${String(i).padStart(2, '0')}`; const newProjectData = { batchId: currentBatchId, creationTimestamp: batchCreationTimestamp, fixCategory: fixCategory, baseProjectName: baseProjectNameVal, areaTask: currentAreaTask, gsd: gsd, assignedTo: "", techNotes: "", status: 'Available', startTimeDay1: null, finishTimeDay1: null, durationDay1Ms: null, startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null, releasedToNextStage: false, lastModifiedTimestamp: batchCreationTimestamp, isReassigned: false, originalProjectId: null }; const docRef = db.collection("projects").doc(); fbBatch.set(docRef, newProjectData); } await fbBatch.commit(); if (newProjectForm) newProjectForm.reset(); } catch (error) { console.error("Error adding projects to Firebase: ", error); alert("Error adding projects. Error: " + error.message); } finally { if (projectFormModal) projectFormModal.style.display = 'none'; } }
        function getManageableBatches() { const allBatchesInfo = {}; projects.forEach(p => { if (p && p.batchId) { if (!allBatchesInfo[p.batchId]) allBatchesInfo[p.batchId] = { batchId: p.batchId, baseProjectName: p.baseProjectName || "N/A", tasksByFix: {} }; if (p.fixCategory && !allBatchesInfo[p.batchId].tasksByFix[p.fixCategory]) allBatchesInfo[p.batchId].tasksByFix[p.fixCategory] = []; if (p.fixCategory) allBatchesInfo[p.batchId].tasksByFix[p.fixCategory].push(p); } }); return Object.values(allBatchesInfo); }
        function renderTLDashboard() { if (!tlDashboardContentElement) { console.error("tlDashboardContentElement not found."); return; } tlDashboardContentElement.innerHTML = ''; const manageableBatches = getManageableBatches(); if (manageableBatches.length === 0) { tlDashboardContentElement.innerHTML = '<p>No project batches found.</p>'; return; } manageableBatches.forEach(batch => { if (!batch || !batch.batchId) return; const batchDiv = document.createElement('div'); batchDiv.classList.add('dashboard-batch-item'); const title = document.createElement('h4'); title.textContent = `Batch: ${batch.baseProjectName || 'Unknown'} (ID: ${batch.batchId.split('_')[1] || 'N/A'})`; batchDiv.appendChild(title); const stagesPresentP = document.createElement('p'); const presentFixCategories = batch.tasksByFix ? Object.keys(batch.tasksByFix).sort((a,b) => FIX_CATEGORIES_ORDER.indexOf(a) - FIX_CATEGORIES_ORDER.indexOf(b)) : []; stagesPresentP.innerHTML = `<strong>Stages Present:</strong> ${presentFixCategories.join(', ') || 'None'}`; batchDiv.appendChild(stagesPresentP); const releaseActionsDiv = document.createElement('div'); releaseActionsDiv.classList.add('dashboard-batch-actions-release'); let latestFixCategoryForBatch = ""; let allTasksInLatestStageReadyForRelease = false; let alreadyReleasedFromLatestStage = true; if (batch.tasksByFix) { FIX_CATEGORIES_ORDER.slice().reverse().forEach(fixCat => { if (batch.tasksByFix[fixCat] && batch.tasksByFix[fixCat].length > 0 && !latestFixCategoryForBatch) { latestFixCategoryForBatch = fixCat; alreadyReleasedFromLatestStage = batch.tasksByFix[fixCat].every(t => t && t.releasedToNextStage && t.status !== 'Reassigned_TechAbsent'); if (!alreadyReleasedFromLatestStage) allTasksInLatestStageReadyForRelease = batch.tasksByFix[fixCat].filter(t => t.status !== 'Reassigned_TechAbsent').every(t => t && (t.status === 'Completed' || t.status === 'Day1Ended_AwaitingNext')); } }); } if (latestFixCategoryForBatch && !alreadyReleasedFromLatestStage) { const currentFixIdx = FIX_CATEGORIES_ORDER.indexOf(latestFixCategoryForBatch); if (currentFixIdx < FIX_CATEGORIES_ORDER.length - 1) { const nextFixCategory = FIX_CATEGORIES_ORDER[currentFixIdx + 1]; const releaseBtn = document.createElement('button'); releaseBtn.textContent = `Release to ${nextFixCategory}`; releaseBtn.classList.add('btn', 'btn-release'); if (!allTasksInLatestStageReadyForRelease) { releaseBtn.disabled = true; releaseBtn.title = `Not all active tasks in ${latestFixCategoryForBatch} are 'Completed' or 'Day 1 Ended'.`; } releaseBtn.onclick = () => releaseBatchToNextFix(batch.batchId, latestFixCategoryForBatch, nextFixCategory); releaseActionsDiv.appendChild(releaseBtn); } } else if (alreadyReleasedFromLatestStage && latestFixCategoryForBatch && FIX_CATEGORIES_ORDER.indexOf(latestFixCategoryForBatch) < FIX_CATEGORIES_ORDER.length -1) { const releasedInfoP = document.createElement('p'); releasedInfoP.innerHTML = `<small><em>(Active tasks released from ${latestFixCategoryForBatch})</em></small>`; releaseActionsDiv.appendChild(releasedInfoP); } batchDiv.appendChild(releaseActionsDiv); const deleteActionsDiv = document.createElement('div'); deleteActionsDiv.classList.add('dashboard-batch-actions-delete'); if (batch.tasksByFix) { FIX_CATEGORIES_ORDER.forEach(fixCat => { if (batch.tasksByFix[fixCat] && batch.tasksByFix[fixCat].length > 0) { const deleteFixBtn = document.createElement('button'); deleteFixBtn.textContent = `Delete ${fixCat} Tasks`; deleteFixBtn.classList.add('btn', 'btn-danger'); deleteFixBtn.onclick = () => { if (confirm(`Are you sure you want to delete all ${fixCat} tasks for batch '${batch.baseProjectName || 'Unknown'}'? IRREVERSIBLE.`)) deleteSpecificFixTasksForBatch(batch.batchId, fixCat); }; deleteActionsDiv.appendChild(deleteFixBtn); } }); } const deleteAllBtn = document.createElement('button'); deleteAllBtn.textContent = 'Delete ALL Tasks for this Batch'; deleteAllBtn.classList.add('btn', 'btn-danger'); deleteAllBtn.onclick = () => { if (confirm(`Are you sure you want to delete ALL tasks for batch '${batch.baseProjectName || 'Unknown'}'? IRREVERSIBLE.`)) deleteProjectBatch(batch.batchId); }; deleteActionsDiv.appendChild(deleteAllBtn); batchDiv.appendChild(deleteActionsDiv); tlDashboardContentElement.appendChild(batchDiv); }); }
        async function releaseBatchToNextFix(batchId, currentFixCategory, nextFixCategory) { if (!db) { alert("Database not initialized!"); return; } if (!batchId || !currentFixCategory || !nextFixCategory) { alert("Error: Missing info to release batch."); return; } try { const sourceTasksSnapshot = await db.collection("projects").where("batchId", "==", batchId).where("fixCategory", "==", currentFixCategory).where("releasedToNextStage", "==", false).get(); if (sourceTasksSnapshot.empty) { alert("No active tasks found for this batch in the current stage to release, or they may have already been released."); refreshAllViews(); return; } const sourceBatchTasks = []; sourceTasksSnapshot.forEach(doc => { const data = doc.data(); if (data.status !== 'Reassigned_TechAbsent') sourceBatchTasks.push({id: doc.id, ...data }); }); if (sourceBatchTasks.length === 0) { alert("No active tasks found for this batch in the current stage to release after filtering."); refreshAllViews(); return; } const allReadyForRelease = sourceBatchTasks.every(p => p && (p.status === 'Completed' || p.status === 'Day1Ended_AwaitingNext')); if (!allReadyForRelease) { alert(`Not all active tasks in batch ID ${batchId} for ${currentFixCategory} are 'Completed' or 'Day 1 Ended'. Cannot release.`); return; } const releaseTimestamp = firebase.firestore.FieldValue.serverTimestamp(); const fbBatch = db.batch(); for (const sourceTask of sourceBatchTasks) { if (!sourceTask || !sourceTask.id) continue; const q = db.collection("projects").where("batchId", "==", sourceTask.batchId).where("areaTask", "==", sourceTask.areaTask).where("fixCategory", "==", nextFixCategory); const existingNextStageTaskSnapshot = await q.get(); let newDocCreated = false; if (existingNextStageTaskSnapshot.empty) { const newTaskData = { batchId: sourceTask.batchId, creationTimestamp: sourceTask.creationTimestamp, fixCategory: nextFixCategory, baseProjectName: sourceTask.baseProjectName, areaTask: sourceTask.areaTask, gsd: sourceTask.gsd, assignedTo: sourceTask.assignedTo, techNotes: "", status: 'Available', startTimeDay1: null, finishTimeDay1: null, durationDay1Ms: null, startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null, releasedToNextStage: false, lastModifiedTimestamp: releaseTimestamp, isReassigned: false, originalProjectId: sourceTask.id }; const newDocRef = db.collection("projects").doc(); fbBatch.set(newDocRef, newTaskData); newDocCreated = true; } else console.log(`Task for ${sourceTask.areaTask} in ${nextFixCategory} already exists. Marking current as released.`); const sourceDocRef = db.collection("projects").doc(sourceTask.id); fbBatch.update(sourceDocRef, { releasedToNextStage: true, lastModifiedTimestamp: releaseTimestamp }); } await fbBatch.commit(); console.log(`Batch ${batchId} (${currentFixCategory}) active tasks processed for release to ${nextFixCategory}.`); } catch (error) { console.error("Error releasing batch to Firebase:", error); alert("Error releasing batch. Error: " + error.message); } }
        async function deleteProjectBatch(batchIdToDelete) { if (!db) { alert("Database not initialized!"); return; } if (!batchIdToDelete) { alert("Error: No Batch ID provided for deletion."); return; } try { const querySnapshot = await db.collection("projects").where("batchId", "==", batchIdToDelete).get(); if (querySnapshot.empty) { console.log(`No projects for batch ${batchIdToDelete} to delete.`); return; } const fbBatch = db.batch(); querySnapshot.forEach(doc => fbBatch.delete(doc.ref)); await fbBatch.commit(); console.log(`Batch ${batchIdToDelete} deleted.`); } catch (error) { console.error(`Error deleting batch ${batchIdToDelete}:`, error); alert("Error deleting batch. Error: " + error.message); } }
        async function deleteSpecificFixTasksForBatch(batchIdToDelete, fixCategoryToDelete) { if (!db) { alert("Database not initialized!"); return; } if (!batchIdToDelete || !fixCategoryToDelete) { alert("Error: Missing Batch ID or Fix Category."); return; } try { const querySnapshot = await db.collection("projects").where("batchId", "==", batchIdToDelete).where("fixCategory", "==", fixCategoryToDelete).get(); if (querySnapshot.empty) { console.log(`No ${fixCategoryToDelete} tasks for batch ${batchIdToDelete} to delete.`); return; } const fbBatch = db.batch(); querySnapshot.forEach(doc => fbBatch.delete(doc.ref)); await fbBatch.commit(); console.log(`${fixCategoryToDelete} tasks for batch ${batchIdToDelete} deleted.`); } catch (error) { console.error(`Error deleting ${fixCategoryToDelete} for batch ${batchIdToDelete}:`, error); alert("Error deleting specific fix tasks. Error: " + error.message); } }
        function renderProjects() { if (!projectTableBody) { console.error("CRITICAL: projectTableBody not found."); return; } projectTableBody.innerHTML = ''; const projectsToRender = [...projects]; try { projectsToRender.sort((a, b) => { if (!a || !b) return 0; if ((a.batchId || "") < (b.batchId || "")) return -1; if ((a.batchId || "") > (b.batchId || "")) return 1; const fixOrderA = FIX_CATEGORIES_ORDER.indexOf(a.fixCategory || ""); const fixOrderB = FIX_CATEGORIES_ORDER.indexOf(b.fixCategory || ""); if (fixOrderA < fixOrderB) return -1; if (fixOrderA > fixOrderB) return 1; if ((a.areaTask || "") < (b.areaTask || "")) return -1; if ((a.areaTask || "") > (b.areaTask || "")) return 1; if ((a.areaTask || "") === (b.areaTask || "")) { let tsA_create = a.creationTimestamp; let tsB_create = b.creationTimestamp; if (tsA_create && typeof tsA_create.toMillis === 'function') tsA_create = tsA_create.toMillis(); if (tsB_create && typeof tsB_create.toMillis === 'function') tsB_create = tsB_create.toMillis(); tsA_create = typeof tsA_create === 'number' ? tsA_create : 0; tsB_create = typeof tsB_create === 'number' ? tsB_create : 0; if (tsA_create > tsB_create) return -1; if (tsA_create < tsB_create) return 1; } const statusAVal = STATUS_ORDER[a.status || ""] || 99; const statusBVal = STATUS_ORDER[b.status || ""] || 99; if (statusAVal < statusBVal) return -1; if (statusAVal > statusBVal) return 1; return 0; }); } catch(sortError) { console.error("Error during project sort:", sortError); } let currentBatchIdForDisplay = null; let currentFixCategoryForHeader = null; projectsToRender.forEach(project => { if (!project || !project.id || !project.batchId || !project.fixCategory) { console.warn("Skipping malformed project:", project); return; } if (project.batchId !== currentBatchIdForDisplay) { currentBatchIdForDisplay = project.batchId; currentFixCategoryForHeader = null; const batchHeaderRow = projectTableBody.insertRow(); batchHeaderRow.classList.add('batch-header-row'); const batchHeaderCell = batchHeaderRow.insertCell(); batchHeaderCell.setAttribute('colspan', NUM_TABLE_COLUMNS.toString()); batchHeaderCell.textContent = `Project Batch: ${project.baseProjectName || 'Unknown'} (ID: ${project.batchId.split('_')[1] || 'N/A'})`; } if (project.fixCategory !== currentFixCategoryForHeader) { currentFixCategoryForHeader = project.fixCategory; const groupStateKey = `${project.batchId}_${currentFixCategoryForHeader}`; if (groupVisibilityState[groupStateKey] === undefined) groupVisibilityState[groupStateKey] = { isExpanded: true }; const groupHeaderRow = projectTableBody.insertRow(); groupHeaderRow.classList.add('fix-group-header'); const groupHeaderCell = groupHeaderRow.insertCell(); groupHeaderCell.setAttribute('colspan', NUM_TABLE_COLUMNS.toString()); const toggleBtn = document.createElement('button'); toggleBtn.classList.add('btn', 'btn-group-toggle'); const isExpanded = groupVisibilityState[groupStateKey]?.isExpanded !== false; toggleBtn.textContent = isExpanded ? '−' : '+'; toggleBtn.title = isExpanded ? `Collapse ${currentFixCategoryForHeader}` : `Expand ${currentFixCategoryForHeader}`; groupHeaderCell.appendChild(document.createTextNode(`${currentFixCategoryForHeader} `)); groupHeaderCell.appendChild(toggleBtn); groupHeaderCell.onclick = (e) => { if (e.target === toggleBtn || e.target === groupHeaderCell || groupHeaderCell.contains(e.target)) { if (groupVisibilityState[groupStateKey]) { groupVisibilityState[groupStateKey].isExpanded = !groupVisibilityState[groupStateKey].isExpanded; saveGroupVisibilityState(); renderProjects(); } } }; } const row = projectTableBody.insertRow(); const currentGroupStateKeyForRow = `${project.batchId}_${project.fixCategory}`; if (!(groupVisibilityState[currentGroupStateKeyForRow]?.isExpanded !== false)) row.classList.add('hidden-group-row'); if (project.fixCategory) row.classList.add(`${project.fixCategory.toLowerCase()}-row`); if (project.isReassigned) row.classList.add('reassigned-task-highlight'); row.insertCell().textContent = project.fixCategory || 'N/A'; const baseNameCell = row.insertCell(); baseNameCell.textContent = project.baseProjectName || 'N/A'; baseNameCell.classList.add('wrap-text'); row.insertCell().textContent = project.areaTask || 'N/A'; row.insertCell().textContent = project.gsd || 'N/A'; const assignedToCell = row.insertCell(); const assignedToInput = document.createElement('input'); assignedToInput.type = 'text'; assignedToInput.value = project.assignedTo || ''; assignedToInput.placeholder = 'ID'; assignedToInput.classList.add('assigned-to-input'); assignedToInput.disabled = project.status === 'Reassigned_TechAbsent'; assignedToInput.onchange = async (event) => { const newVal = event.target.value.trim(); if (!db || !project.id) { alert("Error: Cannot save. DB or ID missing."); event.target.value = project.assignedTo || ''; return; } try { await db.collection("projects").doc(project.id).update({ assignedTo: newVal, lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp() }); } catch (error) { console.error("Error updating assignedTo:", error); alert("Error saving 'Assigned To'. Error: " + error.message); event.target.value = project.assignedTo || ''; } }; assignedToCell.appendChild(assignedToInput); const statusCell = row.insertCell(); const statusSpan = document.createElement('span'); statusSpan.classList.add('status'); let statusText = (project.status || "Unknown").replace(/([A-Z])(?=[a-z0-9_])/g, ' $1').trim(); if (project.status === "Day1Ended_AwaitingNext") statusText = "Started Available"; if (project.status === "Reassigned_TechAbsent") statusText = "Re-Assigned"; statusSpan.textContent = statusText; statusSpan.classList.add(`status-${(project.status || "unknown").toLowerCase()}`); statusCell.appendChild(statusSpan); const timeFormatOptions = { hour: 'numeric', minute: '2-digit', hour12: true }; let d1s = project.startTimeDay1, d1f = project.finishTimeDay1, d2s = project.startTimeDay2, d2f = project.finishTimeDay2; try { if (d1s && typeof d1s.toDate === 'function') d1s = d1s.toDate(); else if (d1s) d1s = new Date(d1s); else d1s = null; if (d1f && typeof d1f.toDate === 'function') d1f = d1f.toDate(); else if (d1f) d1f = new Date(d1f); else d1f = null; if (d2s && typeof d2s.toDate === 'function') d2s = d2s.toDate(); else if (d2s) d2s = new Date(d2s); else d2s = null; if (d2f && typeof d2f.toDate === 'function') d2f = d2f.toDate(); else if (d2f) d2f = new Date(d2f); else d2f = null; } catch (dateError) { console.error("Error parsing date for " + project.id, dateError); d1s = d1f = d2s = d2f = null; } row.insertCell().textContent = d1s && !isNaN(d1s) ? d1s.toLocaleTimeString('en-US', timeFormatOptions) : '-'; row.insertCell().textContent = d1f && !isNaN(d1f) ? d1f.toLocaleTimeString('en-US', timeFormatOptions) : '-'; row.insertCell().textContent = formatMillisToMinutes(project.durationDay1Ms); row.insertCell().textContent = d2s && !isNaN(d2s) ? d2s.toLocaleTimeString('en-US', timeFormatOptions) : '-'; row.insertCell().textContent = d2f && !isNaN(d2f) ? d2f.toLocaleTimeString('en-US', timeFormatOptions) : '-'; row.insertCell().textContent = formatMillisToMinutes(project.durationDay2Ms); row.insertCell().textContent = formatMillisToMinutes((project.durationDay1Ms || 0) + (project.durationDay2Ms || 0) > 0 ? (project.durationDay1Ms || 0) + (project.durationDay2Ms || 0) : null); const techNotesCell = row.insertCell(); const techNotesInput = document.createElement('textarea'); techNotesInput.value = project.techNotes || ''; techNotesInput.placeholder = 'Notes'; techNotesInput.classList.add('tech-notes-input'); techNotesInput.rows = 1; techNotesInput.id = `techNotes_${project.id}`; techNotesInput.disabled = project.status === 'Reassigned_TechAbsent'; techNotesInput.onchange = async (event) => { const newVal = event.target.value; if (!db || !project.id) { alert("Error: Cannot save. DB or ID missing."); event.target.value = project.techNotes || ''; return; } try { await db.collection("projects").doc(project.id).update({ techNotes: newVal, lastModifiedTimestamp: firebase.firestore.FieldValue.serverTimestamp() }); } catch (error) { console.error("Error updating techNotes:", error); alert("Error saving Tech Notes. Error: " + error.message); event.target.value = project.techNotes || ''; } }; techNotesCell.appendChild(techNotesInput); const actionsCell = row.insertCell(); const btnContainer = document.createElement('div'); const isOriginalReassignedTask = project.status === 'Reassigned_TechAbsent'; const sD1btn = document.createElement('button'); sD1btn.textContent = 'Start D1'; sD1btn.classList.add('btn','btn-day-start'); sD1btn.disabled = project.status !== 'Available' || isOriginalReassignedTask; sD1btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay1'); }; btnContainer.appendChild(sD1btn); const eD1btn = document.createElement('button'); eD1btn.textContent = 'End D1'; eD1btn.classList.add('btn','btn-day-end'); eD1btn.disabled = project.status !== 'InProgressDay1' || isOriginalReassignedTask; eD1btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay1'); }; btnContainer.appendChild(eD1btn); const sD2btn = document.createElement('button'); sD2btn.textContent = 'Start D2'; sD2btn.classList.add('btn','btn-day-start'); sD2btn.disabled = project.status !== 'Day1Ended_AwaitingNext' || isOriginalReassignedTask; sD2btn.onclick = () => { if (project.id) updateProjectState(project.id, 'startDay2'); }; btnContainer.appendChild(sD2btn); const eD2btn = document.createElement('button'); eD2btn.textContent = 'End D2'; eD2btn.classList.add('btn','btn-day-end'); eD2btn.disabled = project.status !== 'InProgressDay2' || isOriginalReassignedTask; eD2btn.onclick = () => { if (project.id) updateProjectState(project.id, 'endDay2'); }; btnContainer.appendChild(eD2btn); const doneBtn = document.createElement('button'); doneBtn.textContent = 'Done'; doneBtn.classList.add('btn','btn-mark-done'); doneBtn.disabled = project.status === 'Completed' || isOriginalReassignedTask; doneBtn.onclick = () => { if (project.id) updateProjectState(project.id, 'markDone'); }; btnContainer.appendChild(doneBtn); const reassignBtn = document.createElement('button'); reassignBtn.textContent = 'Re-Assign'; reassignBtn.classList.add('btn', 'btn-warning'); reassignBtn.title = 'Re-assign task by creating a new entry.'; reassignBtn.disabled = project.status === 'Completed' || isOriginalReassignedTask; reassignBtn.onclick = () => { const currentProjectData = projects.find(p => p.id === project.id); if (currentProjectData) handleReassignment(currentProjectData); else alert("Error: Could not retrieve task data for re-assignment."); }; btnContainer.appendChild(reassignBtn); actionsCell.appendChild(btnContainer); }); }
        async function updateProjectState(projectId, action) { if (!db) { alert("Database not initialized!"); return; } if (!projectId) { alert("Error: Project ID missing."); return; } const projectRef = db.collection("projects").doc(projectId); let currentProjectData; try { const doc = await projectRef.get(); if (!doc.exists) { alert(`Error: Project ${projectId} not found.`); return; } currentProjectData = doc.data(); } catch(error) { console.error("Error fetching project:", error); alert("Error fetching project. Error: " + error.message); return; } if (!currentProjectData) { alert(`Error: Could not get data for project ${projectId}.`); return; } if (currentProjectData.status === 'Reassigned_TechAbsent') { alert("This task instance was re-assigned and is closed. No further status changes allowed on this instance."); return; } const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp(); const clientNowMillis = Date.now(); let updatedFields = { lastModifiedTimestamp: serverTimestamp }; switch (action) { case 'startDay1': if (currentProjectData.status === 'Available') updatedFields = { ...updatedFields, status: 'InProgressDay1', startTimeDay1: serverTimestamp, finishTimeDay1: null, durationDay1Ms: null, startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null }; else console.warn(`Cannot 'startDay1'. Status: ${currentProjectData.status}`); break; case 'endDay1': if (currentProjectData.status === 'InProgressDay1' && currentProjectData.startTimeDay1) updatedFields = { ...updatedFields, status: 'Day1Ended_AwaitingNext', finishTimeDay1: serverTimestamp, durationDay1Ms: calculateDurationMs(currentProjectData.startTimeDay1, clientNowMillis) }; else console.warn(`Cannot 'endDay1'. Status: ${currentProjectData.status}`); break; case 'startDay2': if (currentProjectData.status === 'Day1Ended_AwaitingNext') updatedFields = { ...updatedFields, status: 'InProgressDay2', startTimeDay2: serverTimestamp, finishTimeDay2: null, durationDay2Ms: null }; else console.warn(`Cannot 'startDay2'. Status: ${currentProjectData.status}`); break; case 'endDay2': if (currentProjectData.status === 'InProgressDay2' && currentProjectData.startTimeDay2) updatedFields = { ...updatedFields, status: 'Completed', finishTimeDay2: serverTimestamp, durationDay2Ms: calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis) }; else console.warn(`Cannot 'endDay2'. Status: ${currentProjectData.status}`); break; case 'markDone': if (currentProjectData.status !== 'Completed') { updatedFields.status = 'Completed'; if (currentProjectData.startTimeDay1 && !currentProjectData.finishTimeDay1) { updatedFields.finishTimeDay1 = serverTimestamp; updatedFields.durationDay1Ms = calculateDurationMs(currentProjectData.startTimeDay1, clientNowMillis); } if (currentProjectData.startTimeDay2 && !currentProjectData.finishTimeDay2) { updatedFields.finishTimeDay2 = serverTimestamp; updatedFields.durationDay2Ms = calculateDurationMs(currentProjectData.startTimeDay2, clientNowMillis); } if (!currentProjectData.startTimeDay2) { updatedFields.durationDay2Ms = null; updatedFields.finishTimeDay2 = null; } } else console.warn(`Cannot 'markDone'. Status: ${currentProjectData.status}`); break; default: console.log("Unknown action:", action); return; } if (Object.keys(updatedFields).length > 1) { try { await projectRef.update(updatedFields); console.log(`Project ${projectId} action ${action} updated.`); } catch (error) { console.error(`Error updating project ${projectId}:`, error); alert(`Error updating project. Error: ${error.message}`); } } else console.log(`No fields to update for ${action} on ${projectId}. Status: ${currentProjectData.status}`); }
        async function handleReassignment(originalProjectData) { if (!originalProjectData || !originalProjectData.id) { alert("Cannot re-assign: Original task data is missing."); return; } if (originalProjectData.status === 'Reassigned_TechAbsent') { alert("This task instance has already been re-assigned. You can re-assign the newly created active task if needed."); return; } if (originalProjectData.status === 'Completed') { alert("Cannot re-assign a completed task."); return; } const currentTechId = originalProjectData.assignedTo || "N/A"; const newTechId = prompt(`Task for '${originalProjectData.areaTask}' is currently assigned to '${currentTechId}'.\nEnter New Technician ID for the NEW re-assigned task entry:`); if (newTechId === null) { console.log("Re-assignment cancelled."); return; } const trimmedNewTechId = newTechId.trim(); if (trimmedNewTechId === "") { alert("New Technician ID cannot be empty."); return; } const confirmation = confirm( `Create a NEW task entry for '${trimmedNewTechId}' based on Area/Task '${originalProjectData.areaTask}' (from '${currentTechId}')?\n\n` + `The current task row for '${currentTechId}' will be marked 'Re-Assigned' and closed.\n` + `The new task row will have a distinct highlight and fresh time tracking.` ); if (confirmation) { if (!db) { alert("CRITICAL: Database not initialized!"); return; } const batch = db.batch(); const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp(); const newProjectEntryData = { batchId: originalProjectData.batchId, baseProjectName: originalProjectData.baseProjectName, areaTask: originalProjectData.areaTask, gsd: originalProjectData.gsd, fixCategory: originalProjectData.fixCategory, assignedTo: trimmedNewTechId, status: 'Available', startTimeDay1: null, finishTimeDay1: null, durationDay1Ms: null, startTimeDay2: null, finishTimeDay2: null, durationDay2Ms: null, techNotes: ``, creationTimestamp: serverTimestamp, lastModifiedTimestamp: serverTimestamp, isReassigned: true, originalProjectId: originalProjectData.id, releasedToNextStage: false }; const newProjectRef = db.collection("projects").doc(); batch.set(newProjectRef, newProjectEntryData); const originalProjectRef = db.collection("projects").doc(originalProjectData.id); const originalTaskUpdateData = { status: 'Reassigned_TechAbsent', techNotes: (originalProjectData.techNotes || "") + `\n--- THIS TASK INSTANCE WAS RE-ASSIGNED to '${trimmedNewTechId}' on ${new Date().toLocaleString()}. This instance is now closed. New task ID: ${newProjectRef.id} ---`, lastModifiedTimestamp: serverTimestamp }; batch.update(originalProjectRef, originalTaskUpdateData); try { await batch.commit(); console.log(`Task ${originalProjectData.id} marked re-assigned. New task ${newProjectRef.id} created for ${trimmedNewTechId}.`); } catch (error) { console.error(`Error in batch re-assignment for ${originalProjectData.id}:`, error); alert(`Error re-assigning task. Error: ${error.message}`); } } }
        function refreshAllViews() { try { renderProjects(); if (tlDashboardModal && tlDashboardModal.style.display === 'block') renderTLDashboard(); } catch (e) { console.error("Error during refreshAllViews:", e); alert("Error refreshing view. Error: " + e.message); } }
        
        function setupAuthRelatedDOMReferences() {
            signInBtn = document.getElementById('signInBtn');
            signOutBtn = document.getElementById('signOutBtn');
            userInfoDisplayDiv = document.getElementById('user-info-display');
            userNameP = document.getElementById('userName');
            userEmailP = document.getElementById('userEmail');
            userPhotoImg = document.getElementById('userPhoto');
            appContentDiv = document.getElementById('app-content');
            loadingAuthMessageDiv = document.getElementById('loading-auth-message');
        }

        function setupAuthEventListeners() {
            const provider = new firebase.auth.GoogleAuthProvider();
            if (signInBtn) {
                signInBtn.addEventListener('click', () => {
                    if (!auth) { console.error("Auth not initialized"); return; }
                    auth.signInWithPopup(provider)
                        .catch((error) => {
                            console.error("Sign-in error: ", error);
                            alert("Error signing in: " + error.message + "\nMake sure pop-ups are enabled and your domain is authorized.");
                        });
                });
            }
            if (signOutBtn) {
                signOutBtn.addEventListener('click', () => {
                    if (!auth) { console.error("Auth not initialized"); return; }
                    auth.signOut().catch((error) => {
                        console.error("Sign-out error: ", error);
                        alert("Error signing out: " + error.message);
                    });
                });
            }
        }

        function initializeAppComponents() {
            if (!isAppInitialized) {
                console.log("Initializing app components...");
                setupDOMReferences(); 
                attachEventListeners(); 
                initializeFirebaseAndLoadData(); 
                isAppInitialized = true;
            } else {
                console.log("App components already initialized. Re-attaching Firestore listener.");
                initializeFirebaseAndLoadData(); 
            }
        }

        if (auth) { 
            auth.onAuthStateChanged((user) => {
                if (user) {
                    console.log("Auth state changed: User SIGNED IN - ", user.displayName);
                    if(userNameP) userNameP.textContent = user.displayName || "User";
                    if(userEmailP) userEmailP.textContent = user.email || "No email";
                    if(userPhotoImg) userPhotoImg.src = user.photoURL || ""; // Use a default placeholder if no photo
                    
                    if(userInfoDisplayDiv) userInfoDisplayDiv.style.display = 'flex';
                    if(signInBtn) signInBtn.style.display = 'none';
                    if(loadingAuthMessageDiv) loadingAuthMessageDiv.style.display = 'none'; 
                    if(appContentDiv) appContentDiv.style.display = 'block'; 

                    initializeAppComponents();
                } else {
                    console.log("Auth state changed: User SIGNED OUT");
                    if(userNameP) userNameP.textContent = ''; 
                    if(userEmailP) userEmailP.textContent = '';
                    if(userPhotoImg) userPhotoImg.src = '';

                    if(userInfoDisplayDiv) userInfoDisplayDiv.style.display = 'none';
                    if(signInBtn) signInBtn.style.display = 'block'; // Show sign-in button
                    if(appContentDiv) appContentDiv.style.display = 'none'; 
                    if(loadingAuthMessageDiv) {
                        loadingAuthMessageDiv.innerHTML = '<p>Please sign in to access the Project Tracker.</p>';
                        loadingAuthMessageDiv.style.display = 'block'; 
                    }
                    
                    projects = [];
                    if (projectTableBody) projectTableBody.innerHTML = ''; 
                    if (tlDashboardContentElement) tlDashboardContentElement.innerHTML = '';
                    if (firestoreListenerUnsubscribe) { firestoreListenerUnsubscribe(); firestoreListenerUnsubscribe = null; console.log("Firestore listener detached on sign out."); }
                    isAppInitialized = false; 
                }
            });
        } else {
            console.error("Firebase Auth is not initialized. UI updates based on auth state will not occur.");
            const loadingMsgDiv = document.getElementById('loading-auth-message');
            if (loadingMsgDiv) loadingMsgDiv.innerHTML = `<p style="color:red;">Authentication service failed. Cannot proceed.</p>`;
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded.");
            setupAuthRelatedDOMReferences(); 
            if (auth) { 
                setupAuthEventListeners(); 
                console.log("Auth UI and event listeners set up.");
                // Initial check for user state, onAuthStateChanged will take over
                if (!auth.currentUser && loadingAuthMessageDiv && signInBtn) { // If no user and elements exist
                     signInBtn.style.display = 'block'; // Ensure sign-in button is visible if not logged in
                     loadingAuthMessageDiv.innerHTML = '<p>Please sign in to access the Project Tracker.</p>';
                     loadingAuthMessageDiv.style.display = 'block';
                }
            } else {
                console.error("Firebase Auth not available on DOMContentLoaded. Auth UI setup skipped.");
                const authContainer = document.getElementById('auth-container');
                if (authContainer) {
                    const errorDiv = document.createElement('div');
                    errorDiv.innerHTML = '<p style="color:red; font-weight:bold;">Authentication services could not be loaded. Please check the console and refresh.</p>';
                    authContainer.prepend(errorDiv);
                }
            }
        });
    </script>
</body>
</html>
